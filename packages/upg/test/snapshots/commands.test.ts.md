# Snapshot report for `test/commands.test.ts`

The actual snapshot is saved in `commands.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## zsh

> Snapshot 1

    `  ␊
      ␊
          1   #!/bin/zsh␊
          2   ␊
          3   for ticker in "GOOGL" "AMZN" "AAPL"; do␊
          4     curl "http://real-chart.finance.yahoo.com/table.csv?s=$ticker&d=11&e=31&f=2016&g=d&a=0&b=1&c=2000&ignore=.csv" > "$ticker.csv"␊
          5   done␊
        ␊
        ␊
      ␊
      ␊
    `

## python

> Snapshot 1

    `  ␊
      ␊
          1   import pandas as pd␊
          2   from ggplot import *␊
          3   ␊
          4   tickers = pd.read_csv("tickers.csv")␊
          5   tickers["cumulative_return"] = tickers.groupby("ticker")["price_close"].pct_change()␊
          6   cumulative_returns = tickers.groupby(["date"])["cumulative_return"].sum()␊
          7   ␊
          8   ggplot(aes(x='date', y='cumulative_return'), data=cumulative_returns) +\\␊
          9       geom_line() +\\␊
         10       ggtitle("Cumulative Returns by Ticker")␊
        ␊
        ␊
      ␊
      ␊
    `

## typescript

> Snapshot 1

    `  ␊
      ␊
          1   var Y = function(f) {␊
          2     return (function(x) {␊
          3       return f(function(y) { return (x(x))(y); });␊
          4     })(function(x) {␊
          5       return f(function(y) { return (x(x))(y); });␊
          6     });␊
          7   };␊
          8   ␊
          9   console.log(Y(function(fac) {␊
         10     return function(n) {␊
         11       return n <= 2 ? n : fac(n - 1) * n;␊
         12     };␊
         13   })(5));␊
        ␊
        ␊
      ␊
      ␊
    `

## mandelbrot

> Snapshot 1

    `  ␊
      ␊
          1   import numpy as np␊
          2   import matplotlib.pyplot as plt␊
          3   ␊
          4   def mandelbrot( h,w, maxit=20 ):␊
          5       """Returns an image of the Mandelbrot fractal of size (h,w)."""␊
          6       y,x = np.ogrid[ -1.4:1.4:h*1j, -2:0.8:w*1j ]␊
          7       c = x+y*1j␊
          8       z = c␊
          9       divtime = maxit + np.zeros(z.shape, dtype=int)␊
         10   ␊
         11       for i in range(maxit):␊
         12           z = z**2 + c␊
         13           diverge = z*np.conj(z) > 2**2            # who is diverging␊
         14           div_now = diverge & (divtime==maxit)  # who is diverging now␊
         15           divtime[div_now] = i                  # note when␊
         16           z[diverge] = 2                        # avoid diverging too much␊
         17   ␊
         18       return divtime␊
         19   ␊
         20   plt.imshow(mandelbrot(400,400))␊
         21   plt.show()␊
        ␊
        ␊
      ␊
      ␊
    `
