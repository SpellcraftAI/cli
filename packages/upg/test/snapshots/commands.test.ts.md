# Snapshot report for `test/commands.test.ts`

The actual snapshot is saved in `commands.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## zsh

> Generated source code

    `for ((i=0;i<30;i++)); do␊
      echo $((2**$i-1))␊
    done`

> Runtime output

    {
      code: 0,
      stdout: `0␊
      1␊
      3␊
      7␊
      15␊
      31␊
      63␊
      127␊
      255␊
      511␊
      1023␊
      2047␊
      4095␊
      8191␊
      16383␊
      32767␊
      65535␊
      131071␊
      262143␊
      524287␊
      1048575␊
      2097151␊
      4194303␊
      8388607␊
      16777215␊
      33554431␊
      67108863␊
      134217727␊
      268435455␊
      536870911`,
    }

## python

> Generated source code

    `import pandas as pd␊
    from ggplot import *␊
    ␊
    tickers = pd.read_csv("tickers.csv")␊
    tickers["cumulative_return"] = tickers.groupby("ticker")["price_close"].pct_change()␊
    cumulative_returns = tickers.groupby(["date"])["cumulative_return"].sum()␊
    ␊
    ggplot(aes(x='date', y='cumulative_return'), data=cumulative_returns) +\\␊
        geom_line() +\\␊
        ggtitle("Cumulative Returns by Ticker")`

> Runtime output

    {
      code: 0,
      stdout: '',
    }

## typescript

> Generated source code

    `var Y = function(f) {␊
      return (function(x) {␊
        return f(function(y) { return (x(x))(y); });␊
      })(function(x) {␊
        return f(function(y) { return (x(x))(y); });␊
      });␊
    };␊
    ␊
    console.log(Y(function(fac) {␊
      return function(n) {␊
        return n <= 2 ? n : fac(n - 1) * n;␊
      };␊
    })(5));`

> Runtime output

    {
      code: 0,
      stdout: '120',
    }

## mandelbrot

> Generated source code

    `import numpy as np␊
    import matplotlib.pyplot as plt␊
    ␊
    def mandelbrot( h,w, maxit=20 ):␊
        """Returns an image of the Mandelbrot fractal of size (h,w)."""␊
        y,x = np.ogrid[ -1.4:1.4:h*1j, -2:0.8:w*1j ]␊
        c = x+y*1j␊
        z = c␊
        divtime = maxit + np.zeros(z.shape, dtype=int)␊
    ␊
        for i in range(maxit):␊
            z = z**2 + c␊
            diverge = z*np.conj(z) > 2**2            # who is diverging␊
            div_now = diverge & (divtime==maxit)  # who is diverging now␊
            divtime[div_now] = i                  # note when␊
            z[diverge] = 2                        # avoid diverging too much␊
    ␊
        return divtime␊
    ␊
    plt.imshow(mandelbrot(400,400))␊
    plt.show()`

> Runtime output

    {
      code: 0,
      stdout: '',
    }

## Next.js page

> Generated source code

    `import * as React from 'react';␊
    import { NextPage } from 'next';␊
    ␊
    interface Props {␊
      counter: number;␊
    }␊
    ␊
    const CounterPage: NextPage<Props> = ({ counter }) => (␊
      <div>␊
        <h1>Hello World</h1>␊
        <p>Counter: {counter}</p>␊
        <button onClick={() => alert('pressed!')}>Press Me</button>␊
      </div>␊
    );␊
    ␊
    export default CounterPage;`
