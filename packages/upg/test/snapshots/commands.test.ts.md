# Snapshot report for `test/commands.test.ts`

The actual snapshot is saved in `commands.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## zsh

> find the first 5 Mersenne primes without third party libraries (zsh)
> Source code

    `#!/usr/bin/env zsh␊
    ␊
    # Set the maximum number of Mersenne primes to find␊
    MAX_PRIMES=5␊
    ␊
    # Initialize the counter and the list of primes␊
    COUNT=0␊
    PRIMES=()␊
    ␊
    # Start the loop␊
    N=2␊
    while [ $COUNT -lt $MAX_PRIMES ]; do␊
      # Check if N is prime␊
      is_prime=1␊
      for (( i=2; i<N; i++ )); do␊
        if [ $((N%i)) -eq 0 ]; then␊
          is_prime=0␊
          break␊
        fi␊
      done␊
    ␊
      # If N is prime, check if it is a Mersenne prime␊
      if [ $is_prime -eq 1 ]; then␊
        MERSENNE=$((2**N-1))␊
        is_mersenne_prime=1␊
        for (( i=2; i<MERSENNE; i++ )); do␊
          if [ $((MERSENNE%i)) -eq 0 ]; then␊
            is_mersenne_prime=0␊
            break␊
          fi␊
        done␊
    ␊
        # If MERSENNE is prime, add it to the list␊
        if [ $is_mersenne_prime -eq 1 ]; then␊
          PRIMES+=($MERSENNE)␊
          COUNT=$((COUNT+1))␊
        fi␊
      fi␊
    ␊
      # Increment N␊
      N=$((N+1))␊
    done␊
    ␊
    # Print the list of Mersenne primes␊
    echo "The first $MAX_PRIMES Mersenne primes are:"␊
    echo "${PRIMES[@]}"`

> find the first 5 Mersenne primes without third party libraries (zsh)
> Runtime output

    {
      code: 0,
      stdout: `The first 5 Mersenne primes are:␊
      3 7 31 127 8191`,
    }

## python

> load the ticker history from tickers.csv, and plot the total return over time using ggplot and pandas (python)
> Source code

    `import pandas as pd␊
    import ggplot␊
    ␊
    # Load the ticker history from tickers.csv␊
    ticker_data = pd.read_csv('tickers.csv')␊
    ␊
    # Calculate the total return over time␊
    ticker_data['total_return'] = ticker_data['close'] / ticker_data['open'] - 1␊
    ␊
    # Plot the total return over time using ggplot and pandas␊
    ggplot.ggplot(ticker_data, aes(x='date', y='total_return')) + \\␊
        ggplot.geom_line() + \\␊
        ggplot.ggtitle('Total Return Over Time')`

> load the ticker history from tickers.csv, and plot the total return over time using ggplot and pandas (python)
> Runtime output

    {
      code: 0,
      stdout: '',
    }

## typescript

> define Y combinator function Y(f) and demo using console.log (typescript)
> Source code

    `// Y Combinator Function␊
    function Y(f) {␊
      return (x => f(y => x(x)(y)))(x => f(y => x(x)(y)));␊
    }␊
    ␊
    // Demo using console.log␊
    const factorial = Y(f => n => (n === 0 ? 1 : n * f(n - 1)));␊
    console.log(factorial(5)); // 120`

> define Y combinator function Y(f) and demo using console.log (typescript)
> Runtime output

    {
      code: 0,
      stdout: '120',
    }

## mandelbrot

> plot the Mandelbrot set (python)
> Source code

    `import numpy as np␊
    import matplotlib.pyplot as plt␊
    ␊
    # Set the maximum number of iterations␊
    max_iterations = 100␊
    ␊
    # Set the size of the image␊
    width, height = 1000, 1000␊
    ␊
    # Create a new image in RGB mode␊
    img = np.zeros((height, width, 3))␊
    ␊
    # Set the initial values for the complex plane␊
    xmin, xmax = -2.5, 1.0␊
    ymin, ymax = -1.25, 1.25␊
    ␊
    # Calculate the pixel size␊
    dx = (xmax - xmin) / width␊
    dy = (ymax - ymin) / height␊
    ␊
    # Iterate over the image␊
    for x in range(width):␊
        for y in range(height):␊
            # Convert the pixel coordinates to complex numbers␊
            c = complex(xmin + x * dx, ymin + y * dy)␊
            z = 0␊
            for i in range(max_iterations):␊
                # Calculate the Mandelbrot set␊
                z = z * z + c␊
                if abs(z) > 2:␊
                    break␊
            # Set the color of the pixel␊
            img[y, x] = (i / max_iterations, 0, 0)␊
    ␊
    # Show the image␊
    plt.imshow(img)␊
    plt.show()`

> plot the Mandelbrot set (python)
> Runtime output

    {
      code: 0,
      stdout: '',
    }

## Next.js page

> export a Next.js page called CounterPage which renders a header saying Hello World, and a counter which is incremented by a blue button labeled Press Me (typescript)
> Source code

    `import React from 'react';␊
    import { useState } from 'react';␊
    ␊
    export const CounterPage = () => {␊
      const [count, setCount] = useState(0);␊
    ␊
      return (␊
        <div>␊
          <h1>Hello World</h1>␊
          <p>Counter: {count}</p>␊
          <button␊
            style={{ backgroundColor: 'blue' }}␊
            onClick={() => setCount(count + 1)}␊
          >␊
            Press Me␊
          </button>␊
        </div>␊
      );␊
    };`

## gene splicing

> clusters time-series gene expression signatures using smoothing spline clustering (python)
> Source code

    `import numpy as np␊
    from scipy.interpolate import UnivariateSpline␊
    from sklearn.cluster import KMeans␊
    ␊
    # Load the gene expression data␊
    data = np.loadtxt('gene_expression.txt')␊
    ␊
    # Create a smoothing spline for each gene expression signature␊
    splines = []␊
    for i in range(data.shape[1]):␊
        splines.append(UnivariateSpline(data[:,i], s=0.1))␊
    ␊
    # Create a matrix of smoothed gene expression values␊
    smoothed_data = np.zeros(data.shape)␊
    for i in range(data.shape[1]):␊
        smoothed_data[:,i] = splines[i](data[:,i])␊
    ␊
    # Cluster the smoothed gene expression values using K-Means␊
    kmeans = KMeans(n_clusters=3).fit(smoothed_data)␊
    ␊
    # Print the cluster labels␊
    print(kmeans.labels_)`
