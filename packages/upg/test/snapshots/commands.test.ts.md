# Snapshot report for `test/commands.test.ts`

The actual snapshot is saved in `commands.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## zsh

> Generated source code

    `#!/bin/zsh␊
    ␊
    # Print the first 30 Mersenne primes␊
    ␊
    # Initialize counter␊
    i=1;␊
    ␊
    # Loop through 30 iterations␊
    while [ $i -le 30 ]; do␊
      # Calculate Mersenne prime␊
      prime=$((2**$i - 1));␊
      # Print prime␊
      echo $prime;␊
      # Increment counter␊
      i=$((i + 1));␊
    done`

> Runtime output

    {
      code: 0,
      stdout: `1␊
      3␊
      7␊
      15␊
      31␊
      63␊
      127␊
      255␊
      511␊
      1023␊
      2047␊
      4095␊
      8191␊
      16383␊
      32767␊
      65535␊
      131071␊
      262143␊
      524287␊
      1048575␊
      2097151␊
      4194303␊
      8388607␊
      16777215␊
      33554431␊
      67108863␊
      134217727␊
      268435455␊
      536870911␊
      1073741823`,
    }

## python

> Generated source code

    `import pandas as pd;␊
    import ggplot;␊
    ␊
    # Load the ticker history from tickers.csv␊
    tickers = pd.read_csv('tickers.csv');␊
    ␊
    # Calculate the cumulative returns of tickers by price_close over time␊
    tickers['cumulative_returns'] = tickers.price_close.cumsum();␊
    ␊
    # Plot using ggplot and pandas␊
    ggplot.ggplot(tickers, aes(x='date', y='cumulative_returns')) + \\␊
        ggplot.geom_line() + \\␊
        ggplot.ggtitle('Cumulative Returns of Tickers by Price_Close Over Time');`

> Runtime output

    {
      code: 0,
      stdout: '',
    }

## typescript

> Generated source code

    `// Define Y combinator function␊
    const Y = (f) => (x => f(v => x(x)(v)))(x => f(v => x(x)(v)));␊
    ␊
    // Demo using console.log␊
    console.log(Y((f) => (x) => x + 1)(0)); // Outputs 1`

> Runtime output

    {
      code: 0,
      stdout: '1',
    }

## mandelbrot

> Generated source code

    `import matplotlib.pyplot as plt;␊
    ␊
    def mandelbrot(x, y, max_iters):␊
        c = complex(x, y)␊
        z = 0.0j␊
        for i in range(max_iters):␊
            z = z*z + c␊
            if (z.real*z.real + z.imag*z.imag) >= 4:␊
                return i␊
        return max_iters␊
    ␊
    columns = 1000␊
    rows = 1000␊
    ␊
    result = [[0]*columns for i in range(rows)]␊
    for row_index, row in enumerate(result):␊
        for column_index, _ in enumerate(row):␊
            x = (column_index - (columns/2)) / (columns/4)␊
            y = (row_index - (rows/2)) / (rows/4)␊
            result[row_index][column_index] = mandelbrot(x, y, 80)␊
    ␊
    plt.imshow(result)␊
    plt.show()`

> Runtime output

    {
      code: 0,
      stdout: '',
    }

## Next.js page

> Generated source code

    `import React from 'react';␊
    ␊
    export const CounterPage = () => {␊
      const [counter, setCounter] = React.useState(0);␊
    ␊
      const handleClick = () => {␊
        setCounter(counter + 1);␊
      };␊
    ␊
      return (␊
        <>␊
          <h1>Hello World</h1>␊
          <p>Counter: {counter}</p>␊
          <button onClick={handleClick}>Press Me</button>␊
        </>␊
      );␊
    };`
